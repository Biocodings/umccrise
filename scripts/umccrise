#!/usr/bin/env python
import os
import sys
import traceback
from os.path import isfile, join, dirname, abspath, isdir
import click
import subprocess
from glob import glob
import tempfile

from ngs_utils.call_process import run_simple
from ngs_utils.file_utils import verify_file, safe_mkdir, verify_dir, splitext_plus
from ngs_utils import logger
from ngs_utils.logger import warn, info, critical
from ngs_utils.utils import set_locale; set_locale()
from ngs_utils import snakemake_utils
from umccrise import package_path
from umccrise import _version as version
from hpc_utils import hpc
from umccrise import prep_inputs, prep_resources


@click.command()
@click.version_option(version.__version__)
@click.argument('input_paths', type=click.Path(exists=True), nargs=-1)
@click.option('-T', '--target', 'target_rule', multiple=True, default=['all'],
              help='Optional list of rules, e.g.: -T pcgr -T coverage -T structural -T small_variants')
@click.option('-o', 'output_dir', type=click.Path(), help='Output directory [def: umccrised]')
@click.option('-s', '--sample', 'sample', help='Comma-separated list of samples or batches to process')
@click.option('-b', '--batch', 'batch', help='Comma-separated list of samples or batches to process')
@click.option('-e', '--exclude', 'exclude', help='Comma-separated list of samples or batches to ignore')
@click.option('--genomes', '--genomes-dir', 'input_genomes_dir', help='Path to the reference data')

# Cluster:
@click.option('-t', '--threads', '-j', '--jobs', '--cores', 'cores', type=click.INT,
              help='Maximum number of cores to use at single time (works both for local and cluster runs)')
@click.option('-c', '--cluster-auto', 'cluster', is_flag=True, help='Submit jobs to cluster')
@click.option('--cluster', '--cluster-cmd', 'cluster_cmd', help='Deprecated. Use --cluster-auto instead')

# Snakemake:
@click.option('--forcerun', 'forcerun', help='Comma-separated rules that will be run even if the outputs exist. Propagated to snakemake, space-separated.')
@click.option('--unlock', is_flag=True, help='Use when you are rerunning after Ctrl+C. Propagated to snakemake.')
@click.option('--rerun-incomplete', is_flag=True, help='[Deprecated]. Propagated to snakemake. Set by default, ignored.')
@click.option('-r', '--restarts', '--restart-times', 'restart_times', default=3,
              help='How many times to try out rerunning rules if they fail. "--restart-times 3" means that the rule '
                   'will be attempted maximum 3 times. Default is 3. Propagated to snakemake (decremented, because '
                   'snakemake interprets it as "how many times to restart after the rule is failed").')
@click.option('-n', '--dryrun', 'dryrun', is_flag=True, help='Propagated to snakemake. Prints rules and commands '
                                                             'to be run without actually executing them.')
@click.option('--report', 'report', help='Propagated to snakemake. Create an HTML report with results and statistics. '
                                         'Needs to end in ".html".')
@click.option('--dag', 'dag', is_flag=True, help='Propagated to snakemake. Print the DAG of jobs in the dot language. '
                                                 'Usage: umccrise --dag > tmp.txt; cat <cleaned-tmp.txt> | dot -Tsvg > dag.svg')
# Other:
@click.option('--s3/--no-s3'  , 'upload_s3',  default=False, help='Upload results to s3 [deprectated]')
@click.option('--igv/--no-igv', 'upload_igv', default=False, help='Generate mini-bams and upload to a s3 bucket [deprectated]')

@click.option('--debug', 'debug', is_flag=True, help='Increases verbosity of messages')

def main(input_paths, target_rule:list = None, output_dir=None, sample=None, batch=None, exclude=None,
         input_genomes_dir=None, cores=None, cluster=False, cluster_cmd=None, forcerun=None,
         unlock=False, rerun_incomplete=False, restart_times=1, dryrun=False,
         upload_s3=False, upload_igv=False, report=None, dag=False, debug=False):
    """
Umccrise (post-process) a bcbio or Dragen project.\n
input_paths: a path to inputs:\n
    * if a dir, treated as a bcbio run folder (a "final" or a "datestamp" directory), or a Dragen run folder\n
    * if files, BAMs and VCF are supported
"""

    output_dir = output_dir or 'umccrised'
    output_dir = safe_mkdir(abspath(output_dir))
    log_dir = safe_mkdir(join(output_dir, 'log'))
    logger.init(log_fpath_=join(log_dir, 'command.txt'), save_previous=True)

    if isfile(join(output_dir, 'all.done')):
        run_simple('touch ' + join(output_dir, 'all.done'))

    conf = dict()

    #######################
    #### Setting paths ####
    #######################

    tmp_dirs = []

    if not isinstance(input_paths, list):
        input_paths = list(input_paths)

    # if a project is passed as a tarball, uncompressing
    clean_input_paths = []
    for input_path in input_paths:
        if isfile(input_path):
            verify_file(input_path, is_critical=True)
            if input_path.endswith('.tar.gz') or input_path.endswith('.tgz'):
                input_project, tmp_dir = extract_tarball_input(output_dir, input_paths, 'Bcbio or Dragen project input')
                tmp_dirs.append(tmp_dir)
                clean_input_paths.append(verify_dir(input_project))
            else:
                clean_input_paths.append(verify_file(input_path))
        if isdir(input_path):
            verify_dir(input_path, is_critical=True)
            clean_input_paths.append(verify_dir(input_path))

    conf['input_paths'] = ','.join(clean_input_paths)

    if input_genomes_dir:
        if isfile(input_genomes_dir):
            input_genomes_dir, tmp_dir = extract_tarball_input(output_dir, input_genomes_dir, 'Genomes directory')
            tmp_dirs.append(tmp_dir)

    # check hpc_utils can find the genomes dir, and error out if not
    hpc.set_genomes_dir(input_genomes_dir)

    conf['genomes_dir'] = verify_dir(hpc.genomes_dir, is_critical=True)
    logger.info(f'Using genomes directory: {hpc.genomes_dir}')

    #####################################
    #### Setting non-path parameters ####
    #####################################

    if sample or batch:
        conf['sample'] = sample or batch
    if exclude:
        conf['exclude'] = exclude
    target_rule = list(target_rule)

    if unlock: conf['unlock'] = 'yes'
    if debug: conf['debug'] = 'yes'

    #########################
    #### Setting cluster ####
    #########################
    cluster_param = ''
    cluster_log_dir = ''
    if cluster or cluster_cmd:
        if cluster_cmd:
            cluster_param = f' --cluster "{cluster_cmd}"'
        else:
            cluster_log_dir = safe_mkdir(join(log_dir, 'cluster'))
            cluster_param = snakemake_utils.make_cluster_cmdl(cluster_log_dir, 'umccrise')

    ################################
    #### Setting CPUs resources ####
    ################################
    run, batch_by_name = prep_inputs(conf, silent=True)
    ncpus_per_batch, ncpus_per_sample, ncpus_available, ncpus_per_node = \
        prep_resources(num_batches=len(batch_by_name), num_samples=len(run.samples),
            ncpus_requested=cores, is_cluster=cluster_param != '',)
    conf['threads_per_batch'] = ncpus_per_batch
    conf['threads_per_sample'] = ncpus_per_sample

    ###############################
    #### Building command line ####
    ###############################
    cmd = ''
    snakefile = join(package_path(), 'Snakefile')
    cmd += (
        f'snakemake '
        f'--snakefile {snakefile} '
        f'{" ".join(target_rule)} '
        f'--printshellcmds '
        f'{"--dryrun " if dryrun else ""}'
        f'{"--dag " if dag else ""}'
        f'{f"--report {report} " if report else ""}'
        f'--directory {output_dir} '
        f'--cores {ncpus_available} '
        f'{f"--local-cores {ncpus_per_node} " if ncpus_per_node else ""}'
        f'--rerun-incomplete '
        f'{f"--restart-times {restart_times - 1}" if restart_times > 1 else ""}'
        f'{cluster_param} '
        f'--config {" ".join(k + "=" + str(v) for k, v in conf.items())} '
    )

    #################
    #### Running ####
    #################

    if unlock:
        print('* Unlocking previous run... *')
        run_simple(cmd + ' --unlock')
        print('* Now rerunning *')

    try:
        run_simple(cmd)
    except subprocess.CalledProcessError:
        logger.error('--------')
        logger.error(f'Error running Umccrise: snakemake returned a non-zero status. Working directory: {output_dir}')
        if cluster_log_dir:
            run_simple(f'chmod -R a+r {cluster_log_dir}', silent=True)
            logger.error(f'Review cluster job logs in {cluster_log_dir}')
        for tmp_dir in tmp_dirs: tmp_dir.cleanup()
        sys.exit(1)
    except KeyboardInterrupt:
        logger.error('--------')
        logger.error(f'Interrupted Umccrise. Fixing logs permissions. Working directory: {output_dir}')
        if cluster_log_dir:
            run_simple(f'chmod -R a+r {cluster_log_dir}', silent=True)
            logger.error(f'Review cluster job logs in {cluster_log_dir}')
        for tmp_dir in tmp_dirs: tmp_dir.cleanup()
        sys.exit(1)
    else:
        logger.info('--------')
        if cluster_log_dir:
            run_simple(f'chmod -R a+r {cluster_log_dir}', silent=True)
        logger.info(f'Finished. Output directory: {output_dir}')
        for tmp_dir in tmp_dirs: tmp_dir.cleanup()


def extract_tarball_input(output_dir, path, description):
    if not path.endswith('.tar.gz') and not path.endswith('.tgz'):
        critical(f'{description} must be either a directory, or a .tar.gz file: {path}')
    input_dir = safe_mkdir(join(output_dir, 'input'))
    tmp_dir = tempfile.TemporaryDirectory(prefix=input_dir)
    run_simple(f'tar -xzf {path} --directory {tmp_dir.name}')
    input_project = join(tmp_dir.name, os.listdir(tmp_dir.name)[0])
    assert isdir(input_project), input_project + " " + str(os.listdir(tmp_dir.name))
    return input_project, tmp_dir


if __name__ == '__main__':
    main()
