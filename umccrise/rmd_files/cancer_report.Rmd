---
author: "University of Melbourne Centre for Cancer Research"
date: "`r format(Sys.time(), '%a %Y-%b-%d')`"
output:
  html_document:
    theme: simplex
    toc: true
    toc_float: true
    code_folding: hide
  rmdformats::material:
    highlight: kate
params:
  title: "Cancer Report for "
  tumor_name: 'x'
  batch_name: 'x'
  genome_build: 'hg19'
  key_genes: 'x'
  af_global: 'x'
  af_keygenes: 'x'
  somatic_snv: 'x'
  somatic_sv: 'x'
  purple_gene_cnv: 'x'
  purple_circos_baf: 'x'
  purple_purity: 'x'
  purple_cnv: 'x'
  purple_germline_cnv: 'x'
description: "Analysis of tumor/normal samples at UMCCR"
title: "`r paste(params$title, params$batch_name)`"
---

```{r knitr-opts, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, echo = TRUE)
```

```{r load_pkgs, message=FALSE, warning=FALSE, eval=TRUE}
library(bookdown)
library(BSgenome)
library(devtools)
library(DT)
library(dplyr)
library(glue)
library(ggplot2)
library(knitr)
library(kableExtra)
library(MutationalPatterns)
library(readr)
library(rmarkdown)
library(stringr)
library(tidyr)
library(vcfR)
ref_genome <- paste0("BSgenome.Hsapiens.UCSC.", params$genome_build)
library(ref_genome, character.only = TRUE)
tx_ref_genome <- paste0("TxDb.Hsapiens.UCSC.", params$genome_build, ".knownGene")
library(tx_ref_genome, character.only = TRUE)
```

```{r render_book_inter, eval=FALSE, echo=FALSE}
params <- list(
  tumor_name='PRJ180471_BK221-NET1',
  batch_name='BK221-NET1__PRJ180471_BK221-NET1',
  genome_build='hg19',
  key_genes='/data/cephfs/punim0010/projects/Diakumis/umccrise/envs/src/ngs-utils/ngs_utils/reference_data/key_genes/umccr_cancer_genes.latest.tsv',
  af_global='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/rmd/afs/af_tumor.txt',
  af_keygenes= '/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/rmd/afs/af_tumor_keygenes.txt',
  somatic_snv='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/rmd/ensemble-with_chr_prefix.vcf',
  somatic_sv='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/BK221-NET1__PRJ180471_BK221-NET1/structural/BK221-NET1__PRJ180471_BK221-NET1-sv-prioritize-manta-pass.tsv',
  purple_gene_cnv='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/rmd/purple.tsv',
  purple_cnv='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/purple/BK221-NET1__PRJ180471_BK221-NET1.purple.cnv',
  purple_germline_cnv='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/purple/BK221-NET1__PRJ180471_BK221-NET1.purple.germline.cnv',
  purple_purity='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/purple/BK221-NET1__PRJ180471_BK221-NET1.purple.purity')

render_me <- function() {
  rmarkdown::render(
    "cancer_report.Rmd",
    params = params)
}
render_me()
```

# Signatures

## Allelic frequencies


<details>
<summary>Desciption</summary>

Allelic frequencies are based on the bcbio somatic ensemble
calls (or the single somatic variant calls if run in single-caller mode).

The following steps occur:

1. `somatic_vcf_sort`: simply sort the input VCF
2. `somatic_vcf_annotate`: [annotate VCF](https://github.com/umccr/vcf_stuff/blob/master/vcf_stuff/filtering/annotate_somatic_vcf.smk)
3. `somatic_vcf_filter`: [filter VCF](https://github.com/umccr/vcf_stuff/blob/master/scripts/filter_somatic_vcf)
4. `somatic_vcf_filter_af10`: soft filter variants where `TUMOR_AF < 0.1`
5. `somatic_vcf_filter_pass`: keep only `.,PASS` variants
6. `subset_to_giab`: keep variants in 'high confidence' regions as determined by the
   [Genome in a Bottle consortium](http://jimb.stanford.edu/giab/)
7. `split_multiallelic`:
   - keep only the `TUMOR_AF` field from `INFO` column
   - split multiallelics into multiple rows
8. Allele frequencies for global and keygenes:
   - `afs`: grab only the `INFO/TUMOR_AF` field and output to final txt file
   - `afs_keygenes`: grab the `CHROM`, `POS`, `ID`, `REF`, `ALT` and `INFO/TUMOR_AF`
     for variants in the UMCCR cancer gene BED file, and output to final txt file

</details>


```{r af_plot, warning=FALSE}
# Global AF
af_global <- readr::read_tsv(params$af_global, col_types = "d") %>%
  dplyr::mutate(set = "Global")

af_keygenes <- readr::read_tsv(params$af_keygenes,
                               col_types = "cicccd") %>%
  dplyr::select(af) %>%
  dplyr::mutate(set = 'Key genes CDS')

af_both <- dplyr::bind_rows(af_global, af_keygenes) %>%
  dplyr::mutate(set = factor(set, levels = c("Global", "Key genes CDS")))

ggplot(data = af_both, aes(af)) +
  geom_histogram(stat = 'bin', binwidth = 0.01, fill = "#0047ab") +
  facet_wrap(~set, scales = 'free_y', drop = FALSE) +
  scale_x_continuous(name = "Allele Frequency",
                     breaks = seq(0, 1, by = 0.1),
                     limits = c(0, 1), expand = c(0, 0)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        panel.grid.minor = element_blank())
```

### AF summary stats

```{r af_stats}
mode2 <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

af_both %>%
  dplyr::group_by(set) %>%
  dplyr::summarise(n = n(),
                   mean = round(mean(af), 2),
                   median = round(median(af), 2),
                   mode = round(mode2(af), 2)) %>%
  tidyr::complete(set, fill = list(n = 0)) %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left") %>%
  kableExtra::column_spec(1, bold = TRUE)
```


## Mutational signature
The [MutationalPatterns](http://bioconductor.org/packages/release/bioc/html/MutationalPatterns.html)
R package is used to generate a mutation signature for our sample. We use the final filtered somatic
calls as input (adjusted to hg19-like format).

```{r importVCF, warning=FALSE}
somatic_snv <- read_vcfs_as_granges(
  params$somatic_snv,
  sample_names = params$tumor_name,
  genome = ref_genome,
  group = "auto+sex")
```

### Somatic change distribution

#### Point mutation spectrum

<details>
<summary>Desciption</summary>

With `mut_type_occurrences`, you can count the mutation type occurrences for the input VCF.
For `C>T` mutations, a distinction is made between `C>T` at CpG sites
and other sites, as deamination of methylated cytosine at CpG sites is a common mutational
process. This is the reason the reference genome is needed.

A mutation spectrum shows the relative contribution of each mutation type in the base
substitution catalogs. The `plot_spectrum` function plots the mean relative contribution of
each of the 6 base substitution types over all samples. Error bars indicate standard deviation
over all samples. The total number of mutations is indicated. The `CT = TRUE` option
distinguishes between `C>T` at CpG sites and other sites.

</details>

```{r somProfile1, warning=FALSE}
type_occurrences <- mut_type_occurrences(vcf_list = somatic_snv, ref_genome = ref_genome)
plot_spectrum(type_occurrences, CT = TRUE)
```

#### Profile of 96 trinucleotides

```{r somProfile2, warning=FALSE}
mut_mat <- mut_matrix(vcf_list = somatic_snv, ref_genome = ref_genome)
plot_96_profile(mut_mat, condensed = TRUE)
```

### Signature reference comparison

<details>
<summary>Description</summary>

The contribution of any set of signatures to the mutational profile of a
sample can be quantified. This unique feature is specifically useful
for mutational signature analyses of small cohorts or individual samples,
but also to relate own findings to known signatures and published findings.
The `fit_to_signatures` function finds the optimal linear combination of
mutational signatures that most closely reconstructs
the mutation matrix by solving a non-negative least-squares constraints problem.

Shown are signatures with positive Contribution values, along with summarised descriptions
and reference signature plots from <https://cancer.sanger.ac.uk/cosmic/signatures>.

</details>

```{r somSig}
# Get Sanger sigs from "http://cancer.sanger.ac.uk/cancergenome/assets/signatures_probabilities.txt"
sig_probs <- file.path("misc/sig/signatures_probabilities.txt")
# better be explicit - the sig_probs file has 7 extra empty columns
col_types <- paste0(c("ccc", paste0(rep("d", 30), collapse = ""), "ccccccc"), collapse = "")
col_names <- c("SubstType", "Trinucleotide", "SomMutType", paste0("Sig", 1:30), paste0("foo", 1:7))
cancer_signatures <-
  readr::read_tsv(sig_probs, col_names = col_names, col_types = col_types, skip = 1) %>%
  dplyr::arrange(SubstType)

# sanity check - need to be in same order
stopifnot(all(cancer_signatures$SomMutType == rownames(mut_mat)))

cancer_signatures <- cancer_signatures %>%
  dplyr::select(4:33) %>%
  as.matrix()

# Fit mutation matrix to cancer signatures
fit_res <- fit_to_signatures(mut_matrix = mut_mat, signatures = cancer_signatures)

# Select signatures with some contribution
fit_res_contr <- fit_res$contribution[fit_res$contribution[, 1] > 0, ]
result <- dplyr::tibble(Signature = names(fit_res_contr), Contribution = fit_res_contr)

sig_table <-
  readr::read_tsv(file = "misc/sig/signatures_description.tsv", col_types = "cc") %>%
  dplyr::mutate(Plot = paste0("![](misc/sig/img/sig-", signature, ".png)"),
                signature = paste0("Sig", signature)) %>%
  dplyr::select(Signature = signature, Description = description, Plot)



result %>%
  dplyr::mutate(Contribution = round(Contribution, 0)) %>%
  dplyr::arrange(-Contribution) %>%
  dplyr::left_join(sig_table, by = "Signature") %>%
  knitr::kable() %>%
  kableExtra::kable_styling(font_size = 11) %>%
  kableExtra::scroll_box(height = "300px")
```

### Rainfall plot

<details>
<summary>description</summary>

A rainfall plot visualizes mutation types and intermutation distance. Rainfall plots can be
used to visualize the distribution of mutations along the genome or a subset of chromosomes.
The y-axis corresponds to the distance of a mutation with the previous mutation and is log10
transformed. Drop-downs from the plots indicate clusters or “hotspots” of mutations.
</details>

```{r rainfall}
chromosomes <- seqnames(get(ref_genome))[1:22]
plot_rainfall(somatic_snv[[1]], chromosomes = chromosomes, cex = 1.5, ylim = 1e+09 )
```

## Prioritised SVs

<details>
<summary>Desciption</summary>

* The input file corresponds to `umccrise/batch/structural/batch-sv-prioritize-manta-pass.tsv`
* It's generated through the following steps:

1. `prep_sv_vcf`:
  * Input: `final/tumor/batch-sv-priorize-manta.vcf.gz`
  * Process: keep variants with FILTER values only in `.`, `PASS`, `Intergenic`, or `MissingAnn`.
  * Output: `umccrise/batch/structural/batch-sv-prioritize-manta.vcf`.
2. `filter_sv_vcf`:
  * Input: above output VCF
  * Process: exclude variants where the `SR` _and_ `PR` alt support of the tumor is less
    than 5; also for those variants where `BPI_AF` of one of the breakpoints
    is less than 10%, exclude them if their `SR` and `PR` alt are less than 10.
  * Output: `umccrise/batch/structural/batch-sv-prioritize-manta-filter.vcf`
3. `prep_sv_tsv`:
  * Input: above output VCF and `final/tumor/batch-sv-prioritize.tsv`
  * Process: find positions in the VCF that are in the TSV file
  * Output: `umccrise/batch/structural/batch-sv-prioritize-manta-pass.tsv`

</details>

```{r sv_prioritize, message=FALSE}
col_types <- "ccciicccccc"
sv_all = NULL
if (length(readLines(con = params$somatic_sv, n = 2)) > 1) {
  sv_all <- readr::read_tsv(params$somatic_sv, col_names = TRUE, col_types = col_types) %>%
    tidyr::unnest(annotation = strsplit(annotation, ',')) %>% # Unpack multiple annotations per region
    tidyr::separate(annotation,
                    c('type', 'annotation', 'gene', 'transcript', 'priority', 'score'),
                    sep = '\\|', convert = TRUE) %>% # Unpack annotation columns %>%
    dplyr::mutate(SR = split_read_support, PR = paired_support_PR) %>%
    dplyr::select(chrom, start, end, gene, priority, score, annotation, type, lof, SR, PR) %>%
    dplyr::distinct() %>%
    dplyr::mutate(chrom = factor(chrom, levels = c(1:22, "X", "Y", "MT")))

  DT::datatable(sv_all, rownames = FALSE, filter = "top",
                extensions = c('Scroller', 'Buttons'),
                options = list(scroller = TRUE, scrollX = TRUE, scrollY = 300,
                               dom = 'Bfrtip', buttons = c('csv', 'excel')))

} else {
  warning('No prioritized events detected')
}
```

### SV LoF in tumor suppressors (by Cancermine)

```{r sv_suppressors, message=FALSE}
key_genes <- readr::read_tsv(params$key_genes)
oncogenes <- key_genes %>% filter(oncogene)
tsgenes <- key_genes %>% filter(tumorsuppressor)

if (!is.null(sv_all)) {
  lof <- sv_all %>%
    dplyr::mutate(lof = stringr::str_replace_all(lof, '\\(|\\)', '')) %>%
    tidyr::unnest(lof = strsplit(lof, ',')) %>%
    tidyr::separate(lof,
                    c('lof_gene', 'geneid', 'tx_count', 'prop_affected'),
                    sep = '\\|') %>%
    dplyr::select(chrom, start, end, lof_gene, tx_count, prop_affected, SR, PR) %>%
    dplyr::filter(lof_gene %in% tsgenes$symbol) %>%
    dplyr::mutate('UMCCR_list' = ifelse(lof_gene %in% key_genes$symbol, 'Yes', '')) %>%
    dplyr::distinct()

  DT::datatable(lof, rownames = FALSE, filter = "top",
                extensions = c('Scroller', 'Buttons'),
                options = list(scroller = TRUE, scrollX = TRUE, scrollY = 300,
                               dom = 'Bfrtip', buttons = c('csv', 'excel'))) %>%
    DT::formatCurrency('start', currency = "", interval = 3, mark = ",", digits = 0) %>%
    DT::formatCurrency('end', currency = "", interval = 3, mark = ",", digits = 0)

} else {
  warning('No prioritized events detected')
}
```

## Transcriptional strand bias analysis

<details>
<summary>Desciption</summary>

We can determine if a gene mutation is on the transcribed or non-transcribed
strand, which can be used to evaluate the involvement of transcription-coupled
repair. By convention base substitutions are regarded as C>X or T>X, so we try
to determine whether the C or T base is on the same strand as the gene
definition. Base substitutions on the same strand as the gene definition are
considered 'untranscribed', and on the opposite strand 'transcribed', since the
gene definitions report the coding or sense strand, which is untranscribed. No
strand information is reported for base substitutions that overlap with more
than one gene on different strands.

</details>

```{r tran_strand_bias, warning=FALSE, message=FALSE}
# Get known genes table from UCSC
if (params$genome_build == 'hg19') {
  genes_list <- genes(TxDb.Hsapiens.UCSC.hg19.knownGene)
} else {
  genes_list <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
}

# Mutation count matrix with strand info (4*6*4=96 -> 96*2=192)
mut_mat_s <- mut_matrix_stranded(somatic_snv,
                                 ref_genome = ref_genome,
                                 ranges = genes_list,
                                 mode = "transcription")

# Mutation count per type and strand
strand_counts <- strand_occurrences(mut_mat_s, by = "all")
# Poisson test for strand asymmetry significance testing
strand_bias <- strand_bias_test(strand_counts)

# mutation spectrum with strand distinction
plot_strand(strand_counts, mode = "relative")
# effect size of strand bias
plot_strand_bias(strand_bias)
```


## Replicative strand bias analysis

<details>
<summary>Desciption</summary>

The involvement of replication-associated mechanisms can be evaluated by
testing for a mutational bias between the leading and lagging strand.
The replication strand is dependent on the locations of replication
origins from which DNA replication is fired.
However, replication timing is dynamic and cell-type specific,
which makes replication strand determination less straightforward than
transcriptional strand bias analysis.
Replication timing profiles can be generated with
Repli-Seq experiments. Once the replication direction is defined,
a strand asymmetry analysis can be performed similarly as the transcription
strand bias analysis.

</details>

```{r rep_strand_bias, warning=FALSE, message=FALSE}
repli_file <- system.file("extdata/ReplicationDirectionRegions.bed",
                          package = "MutationalPatterns")
# start/stop contain scientific notation, so need to be doubles
repli_strand <- read_tsv(repli_file, col_names = TRUE, col_types = "cddcc") %>%
  mutate_if(is.character, as.factor)
repli_strand_granges <- GRanges(
  seqnames = repli_strand$Chr,
  ranges = IRanges(start = repli_strand$Start + 1,
                   end = repli_strand$Stop),
  strand_info = repli_strand$Class)

seqlevelsStyle(repli_strand_granges) <- seqlevelsStyle(base::get(ref_genome))

mut_mat_s_rep <- mut_matrix_stranded(somatic_snv, ref_genome = ref_genome,
                                     ranges = repli_strand_granges,
                                     mode = "replication")
# Mutation count per type and strand
strand_counts_rep <- strand_occurrences(mut_mat_s_rep, by = "all")
# Poisson test for strand asymmetry significance testing
strand_bias_rep <- strand_bias_test(strand_counts_rep)

plot_strand(strand_counts_rep, mode = "relative")
plot_strand_bias(strand_bias_rep)
```

# PURPLE Results

[PURPLE](https://github.com/hartwigmedical/hmftools/tree/master/purity-ploidy-estimator)
is a tool for estimating tumor purity and ploidy. It uses the read depth and
tumor beta allele frequency (BAF) to estimate purity and generate a copy number profile.

## Events in cancer genes

<details>
<summary>Desciption</summary>

Listed are deletions in cancer genes, homozygous deletions of tumor suppressors,
and gains in oncogenes. Oncogenes and tumor suppressors reported by
[Cancermine](https://github.com/jakelever/cancermine).

</details>

```{r cnv_suppressors, message=FALSE}
purple_gene_cnv <- readr::read_tsv(params$purple_gene_cnv, col_types = "ciicdd")

purple_gene_cnv %>%
  dplyr::select(Gene, MinCopyNumber, MaxCopyNumber) %>%
  dplyr::mutate(del = MinCopyNumber < 1.5,
                hom_del = MinCopyNumber < 0.5,
                gain = MinCopyNumber >= 3) %>%
  dplyr::filter(hom_del | gain) %>%
  dplyr::mutate(oncogene = Gene %in% oncogenes$symbol,
                tsgene = Gene %in% tsgenes$symbol,
                key_gene = Gene %in% key_genes$symbol) %>%
  dplyr::filter(oncogene & gain | tsgene & hom_del | key_gene & del) %>%
  dplyr::mutate(
    Event = dplyr::case_when(gain ~ 'Gain', hom_del ~ 'HomDel', TRUE ~ 'Del'),
    Gene_Role = dplyr::case_when(oncogene ~ 'Oncogene', tsgene ~ 'Tumor Suppressor', TRUE ~ ''),
    UMCCR_list = ifelse(key_gene, 'Yes', ''),
    min_cn = round(MinCopyNumber),
    max_cn = round(MaxCopyNumber),
    CopyNumber = ifelse(min_cn == max_cn, min_cn, paste(min_cn, max_cn, sep = '-'))) %>%
  dplyr::arrange(CopyNumber) %>%
  dplyr::select(Gene, CopyNumber, Event, Gene_Role, UMCCR_list) %>%
  DT::datatable(rownames = FALSE, filter = "top", extensions = c('Scroller', 'Buttons'),
                options = list(scroller = TRUE, scrollX = TRUE, scrollY = 300,
                               dom = 'Bfrtip', buttons = c('csv', 'excel')))
```


## Circos

### Plot 1: Somatic SNVs/Indels, Total/Minor CN, SVs

<details>
<summary>Desciption</summary>

* __Track1__: Chromosomes. Darker shaded areas: gaps in reference genome
  (centromeres, heterochromatin & missing short arms)
* __Track2__: Somatic variants (incl. exon, intron and intergenic regions).
    * outer ring: SNP allele frequencies, corrected for tumor purity and scaled from 0 to 100%.
      Each dot represents a single somatic variant, coloured according to the
      type of base change (e.g. C>T/G>A in red).
    * inner ring: short insertion (yellow) and deletion (red) locations.
* __Track3__: Observed __total__ copy number changes adjusted for tumor purity,
  including focal and chromosomal somatic events.
  <span style="color:red">Red</span> = Loss; <span style="color:#32CD32">Green</span> = Gain.
  Scaled from 0 (complete loss) to 6 (high level gains).
  If > 6, shown as 6 with a green dot on the outermost green gridline.
* __Track4__: Observed __minor__ allele copy numbers. Range from 0 to 3.
  Expected normal minor allele copy number is 1, and anything below 1 is shown
  as a loss (<span style="color:#EE7600">Orange</span>), representing an LOH event.
  Minor allele copy numbers above 1 (<span style="color:#7EC0EE">Blue</span>) indicate gains
  of both A and B alleles.
* __Track5__ (Inner circle): Observed structural variants within or between the chromosomes.
    * <span style="color:#7EC0EE">Blue</span> = Translocations
    * <span style="color:red">Red</span> = Deletions
    * <span style="color:#e6e600">Yellow</span> = Insertions
    * <span style="color:#32CD32">Green</span> = Tandem duplications
    * <span style="color:#000000">Black</span> = Inversions

</details>

```{r circos-default1, out.width="80%"}
img_dir <- file.path('img') # created before when copying purple files to tmp dir
knitr::include_graphics(file.path(img_dir, paste0(params$batch_name, '.circos.png')))
```

### Plot 2: Tumor/Normal Allele Ratios, BAF

<details>
<summary>Desciption</summary>

* __Track1__: Chromosomes. Darker shaded areas: gaps in reference genome
  (centromeres, heterochromatin & missing short arms)
* __Track2__: <span style="color:blue">Tumor</span> and <span style="color:#32CD32">Normal</span> Ratios
* __Track3__: <span style="color:#EE7600">Beta Allele Frequency</span>

</details>


```{r circos-default2, out.width="80%"}
knitr::include_graphics(file.path(img_dir, paste0(params$batch_name, '.input.png')))
```

### Plot 3: Total/Minor CN, SVs, BAF

<details>
<summary>Desciption</summary>

* __Track1__: Chromosomes
* __Track2__: <span style="color:#8A2BE2">Beta Allele Frequency</span>
* __Track3__: Total Copy Number Changes (see above)
* __Track4__: Minor Copy Number Changes (see above)
* __Track5__ (Inner circle): Observed Structural Variants (see above)

</details>

```{r circos-baf-plot, out.width="80%"}
knitr::include_graphics(file.path(img_dir, paste0(params$batch_name, '.circos_baf.png')))
```

## Purity and Ploidy Summary

```{r purply}
fn <- file.path(params$purple_purity)
x <- readr::read_tsv(fn, col_types = cols(.default = col_double(),
                                          Gender = col_character(),
                                          Status = col_character())) %>%
  dplyr::mutate_if(is.numeric, round, 2) %>%
  unlist()

tribble(~key, ~value,
        'Sex', x["Gender"],
        'Purity', glue('{x["#Purity"]} ({x["MinPurity"]}-{x["MaxPurity"]})'),
        'Ploidy', glue('{x["Ploidy"]} ({x["MinPloidy"]}-{x["MaxPloidy"]})'),
        'Diploidy Proportion', glue('{x["DiploidProportion"]} ({x["MinDiploidProportion"]}-{x["MaxDiploidProportion"]})'),
        'Polyclonal Proportion', x["PolyclonalProportion"],
        'Purple Version', x["Version"]) %>%
  knitr::kable(format = "html")
```

## UMCCR Gene Somatic CNV Calls

```{r gene-tab}
purple_gene_cnv %>%
  dplyr::rename(min_cn = MinCopyNumber, max_cn = MaxCopyNumber) %>%
  dplyr::filter(Gene %in% key_genes$symbol) %>%
  DT::datatable(filter = "top", rownames = FALSE, extensions = c('Scroller', 'Buttons'),
                options = list(scroller = TRUE, scrollX = TRUE, scrollY = 500,
                               dom = 'Bfrtip', buttons = c('csv', 'excel'))) %>%
  DT::formatCurrency(~ Start + End, currency = "", interval = 3, mark = ",", digits = 0) %>%
  DT::formatRound(~ min_cn + max_cn)
```

## Global Somatic and Germline CNV Summary

```{r germ-som-prep}
fn_som <- file.path(params$purple_cnv)
fn_germ <- file.path(params$purple_germline_cnv)
som <- readr::read_tsv(fn_som, col_types = "ciididdccccccc") %>%
  dplyr::rename(chrom = `#chromosome`, tot_cn = copyNumber) %>%
  dplyr::select(chrom, start, end, tot_cn)
germ <- readr::read_tsv(fn_germ, col_types = "ciiddddccccccc") %>%
  dplyr::select(chrom = `#chromosome`, start, end, tot_cn = copyNumber)

cnv_all <- dplyr::bind_rows(somatic = som, germline = germ, .id = "type")
cnv_all %>%
  mutate(seg_len = end - start) %>%
  group_by(type) %>%
  summarise(n = n(),
            mean_len = round(mean(seg_len), 0),
            med_len = round(median(seg_len), 0),
            min_cn = round(min(tot_cn), 2),
            max_cn = round(max(tot_cn), 2)) %>%
  knitr::kable(format = "html", format.args = list(big.mark = ","))
```

### Somatic Calls

```{r som-tab}
som %>%
  dplyr::mutate(seg_len = end - start) %>%
  DT::datatable(filter = "top", rownames = FALSE,
                extensions = c('Scroller', 'Buttons'),
                options = list(scroller = TRUE, scrollX = TRUE, scrollY = 300,
                               dom = 'Bfrtip', buttons = c('csv', 'excel'))) %>%
  DT::formatCurrency(~ start + end + seg_len, currency = "", interval = 3, mark = ",", digits = 0) %>%
  DT::formatRound('tot_cn')
```

## Other PURPLE Charts

```{r purple-other-plots, out.width="80%"}
knitr::include_graphics(file.path(img_dir, paste0(params$batch_name, '.copyNumber.png')))
knitr::include_graphics(file.path(img_dir, paste0(params$batch_name, '.minor_allele.png')))
knitr::include_graphics(file.path(img_dir, paste0(params$batch_name, '.variant.png')))
```


# Software Versions

## umccrise version

```{r um-version}
umv <- system("umccrise --version", intern = TRUE)
```

__`r umv`__


## R package info

<details>
<summary>Session Info</summary>

```{r eval=TRUE}
si <- devtools::session_info(include_base = TRUE)
si_pl <- unclass(si$platform) %>% as_tibble() %>% t()
si_pkg <- unclass(si$packages) %>%
  dplyr::as_tibble() %>%
  dplyr::select(package, version = ondiskversion, path, datestamp = date)



dplyr::tibble(var = row.names(si_pl),
              value = si_pl[, , drop = TRUE]) %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left") %>%
  kableExtra::column_spec(1, bold = TRUE)

knitr::kable(si_pkg, format = "html") %>%
  kableExtra::kable_styling(full_width = TRUE, position = "left") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::scroll_box(height = "400px")
```
</details>
