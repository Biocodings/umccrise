---
author: "University of Melbourne Centre for Cancer Research"
date: "`r format(Sys.time(), '%a %Y-%b-%d')`"
output:
  html_document:
    theme: simplex
    toc: true
    toc_float: false
    #code_folding: hide
    code_download: true
  rmdformats::material:
    highlight: kate
params:
  title: "Cancer Report for Sample "
  tumor_name: 'x'
  batch_name: 'x'
  genome_build: 'hg19'
  key_genes: '/Users/vsaveliev/spa/extras/vlad/synced/NGS_Utils/ngs_utils/reference_data/key_genes/umccr_cancer_genes.latest.tsv'
  af_global: 'x'
  af_keygenes: 'x'
  somatic_snv: 'x'
  somatic_sv: 'x'
  purple_gene_cnv: 'x'
  purple_circos_baf: 'x'
  purple_purity: 'x'
  purple_cnv: 'x'
  purple_qc: 'x'
description: "Analysis of tumor/normal samples at UMCCR"
title: "`r paste(params$title, params$batch_name)`"
---

<style type="text/css">
.main-container {
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r knitr_opts, include=F}
knitr::opts_chunk$set(collapse = TRUE, echo = FALSE,
                      warning = FALSE, message = FALSE)
```

```{r render_book_inter, eval=F, echo=F}
params_tmp <- list(
  spartan = list(
    tumor_name='PRJ180471_BK221-NET1',
    batch_name='BK221-NET1__PRJ180471_BK221-NET1',
    genome_build='hg19',
    key_genes='/Users/vsaveliev/spa/extras/vlad/synced/NGS_Utils/ngs_utils/reference_data/key_genes/umccr_cancer_genes.latest.tsv',
    af_global=      '~/spa/tmp/umccrise_test_sv_newtsv_cluster5/work/E180__PRJ180261_E180-T01-D/rmd/afs/af_tumor.txt',
    af_keygenes=    '~/spa/tmp/umccrise_test_sv_newtsv_cluster5/work/E180__PRJ180261_E180-T01-D/rmd/afs/af_tumor_keygenes.txt',
    somatic_snv=    '~/spa/tmp/umccrise_test_sv_newtsv_cluster5/work/E180__PRJ180261_E180-T01-D/rmd/ensemble-with_chr_prefix.vcf',
    somatic_sv='/Users/vsaveliev/spa/tmp/umccrise_test_sv_newtsv_cluster2/E180__PRJ180261_E180-T01-D/structural/E180__PRJ180261_E180-T01-D-manta.tsv',
    purple_gene_cnv='~/spa/tmp/umccrise_test_sv_newtsv_cluster5/work/E180__PRJ180261_E180-T01-D/rmd/purple.tsv',
    purple_cnv='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/purple/BK221-NET1__PRJ180471_BK221-NET1.purple.cnv',
    purple_purity='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/purple/BK221-NET1__PRJ180471_BK221-NET1.purple.purity',
    purple_qc='/data/cephfs/punim0010/projects/Diakumis/test_umccrise/bk221-net1/umccrised/work/BK221-NET1__PRJ180471_BK221-NET1/purple/BK221-NET1__PRJ180471_BK221-NET1.purple.qc'),

  raijin = list(
    tumor_name='PRJ180598_SFRC01073-S2T',
    batch_name='SFRC01073__PRJ180598_SFRC01073-S2T',
    genome_build='hg19',
    key_genes='/g/data3/gx8/projects/Diakumis/umccrise/umccrise/envs/src/ngs-utils/ngs_utils/reference_data/key_genes/umccr_cancer_genes.latest.tsv',
    af_global='/g/data3/gx8/projects/Diakumis/umccrise/test_umccrise/umccrised/work/SFRC01073__PRJ180598_SFRC01073-S2T/rmd/afs/af_tumor.txt',
    af_keygenes='/g/data3/gx8/projects/Diakumis/umccrise/test_umccrise/umccrised/work/SFRC01073__PRJ180598_SFRC01073-S2T/rmd/afs/af_tumor_keygenes.txt',
    somatic_snv='/g/data3/gx8/projects/Diakumis/umccrise/test_umccrise/umccrised/work/SFRC01073__PRJ180598_SFRC01073-S2T/rmd/ensemble-with_chr_prefix.vcf',
    somatic_sv='/g/data3/gx8/projects/Diakumis/umccrise/test_umccrise/umccrised/SFRC01073__PRJ180598_SFRC01073-S2T/structural/SFRC01073__PRJ180598_SFRC01073-S2T-manta.tsv',
    purple_gene_cnv='/g/data3/gx8/projects/Diakumis/umccrise/test_umccrise/umccrised/work/SFRC01073__PRJ180598_SFRC01073-S2T/rmd/purple.tsv',
    purple_cnv='/g/data3/gx8/projects/Diakumis/umccrise/test_umccrise/umccrised/work/SFRC01073__PRJ180598_SFRC01073-S2T/purple/SFRC01073__PRJ180598_SFRC01073-S2T.purple.cnv',
    purple_purity='/g/data3/gx8/projects/Diakumis/umccrise/test_umccrise/umccrised/work/SFRC01073__PRJ180598_SFRC01073-S2T/purple/SFRC01073__PRJ180598_SFRC01073-S2T.purple.purity',
    purple_qc='/g/data3/gx8/projects/Diakumis/umccrise/test_umccrise/umccrised/work/SFRC01073__PRJ180598_SFRC01073-S2T/purple/SFRC01073__PRJ180598_SFRC01073-S2T.purple.qc'),

  local = list(
    tumor_name='PRJ180598_SFRC01073-S2T',
    batch_name='SFRC01073__PRJ180598_SFRC01073-S2T',
    genome_build='hg19',
    key_genes='~/Desktop/projects/umccr/NGS_Utils/ngs_utils/reference_data/key_genes/umccr_cancer_genes.latest.tsv',
    af_global='data/sig/af_tumor_notempty.txt',
    af_keygenes= 'data/sig/keygenes_notempty.txt',
    somatic_snv='data/sig/ensemble-with_chr_prefix.vcf',
    # somatic_sv='data/empty_manta.tsv',
    somatic_sv='data/SFRC01073__PRJ180598_SFRC01073-S2T-manta.tsv',
    purple_gene_cnv='data/purple/purple.tsv',
    purple_cnv='data/purple2/SFRC01073__PRJ180598_SFRC01073-S2T.purple.cnv',
    purple_purity='data/purple2/SFRC01073__PRJ180598_SFRC01073-S2T.purple.purity',
    purple_qc='data/purple2/SFRC01073__PRJ180598_SFRC01073-S2T.purple.qc')
)

params <- params_tmp[["local"]]

render_me <- function() {
  rmarkdown::render(
    "cancer_report.Rmd",
    params = params)
}
render_me()
```

```{r load_pkgs}
library(BSgenome)
library(devtools)
library(DT)
library(dplyr)
library(glue)
library(ggplot2)
library(knitr)
library(kableExtra)
library(MutationalPatterns)
library(readr)
library(rmarkdown)
library(stringr)
library(tidyr)
library(purrr)
ref_genome <- paste0("BSgenome.Hsapiens.UCSC.", params$genome_build)
library(ref_genome, character.only = TRUE)
tx_ref_genome <- paste0("TxDb.Hsapiens.UCSC.", params$genome_build, ".knownGene")
library(tx_ref_genome, character.only = TRUE)
```

```{r allele_freq_prep}
#---- Allele Frequencies ----#
set.seed(42)
af_global <-
  readr::read_tsv(params$af_global, col_types = "d") %>%
  dplyr::mutate(set = "Global")

af_keygenes <-
  readr::read_tsv(params$af_keygenes, col_types = "cicccd") %>%
  dplyr::select(af) %>%
  dplyr::mutate(set = 'Key genes CDS')

af_both <-
  dplyr::bind_rows(af_global, af_keygenes) %>%
  dplyr::mutate(set = factor(set, levels = c("Global", "Key genes CDS")))

mode2 <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

af_stats <- af_both %>%
  dplyr::group_by(set) %>%
  dplyr::summarise(n = n(),
                   mean = round(mean(af), 2),
                   median = round(median(af), 2),
                   mode = round(mode2(af), 2)) %>%
  tidyr::complete(set, fill = list(n = 0))

```

```{r mutational_sigs_prep}
#---- Mutational Signatures ----#
somatic_snv <- MutationalPatterns::read_vcfs_as_granges(
  vcf_files = params$somatic_snv,
  sample_names = params$tumor_name,
  genome = ref_genome,
  group = "auto+sex")

mut_mat <- MutationalPatterns::mut_matrix(vcf_list = somatic_snv, ref_genome = ref_genome)

# Get Sanger sigs from "http://cancer.sanger.ac.uk/cancergenome/assets/signatures_probabilities.txt"
sig_probs <- file.path("misc/sig/signatures_probabilities.txt")
# better be explicit - the sig_probs file has 7 extra empty columns
col_types <- paste0(c("ccc", paste0(rep("d", 30), collapse = ""), "ccccccc"), collapse = "")
col_names <- c("SubstType", "Trinucleotide", "SomMutType", paste0("Sig", 1:30), paste0("foo", 1:7))
cancer_signatures <-
  readr::read_tsv(sig_probs, col_names = col_names, col_types = col_types, skip = 1) %>%
  dplyr::arrange(SubstType)

# sanity check - need to be in same order
stopifnot(all(cancer_signatures$SomMutType == rownames(mut_mat)))

cancer_signatures <- cancer_signatures %>%
  dplyr::select(4:33) %>%
  as.matrix()

# Fit mutation matrix to cancer signatures
fit_res <- MutationalPatterns::fit_to_signatures(mut_matrix = mut_mat, signatures = cancer_signatures)

# Select signatures with some contribution
fit_res_contr <- fit_res$contribution[fit_res$contribution[, 1] > 0, ]
mut_sig_contr <-
  dplyr::tibble(Signature = names(fit_res_contr), Contribution = fit_res_contr) %>%
  dplyr::mutate(Contribution = round(Contribution, 0)) %>%
  dplyr::arrange(-Contribution)
```

```{r sv_prioritize_prep}
#---- Structural Variants ----#
subset_genes <- function(genes, ind) {
  genes %>%
    stringr::str_split('&') %>%
    purrr::map(~ .[ind] %>%
          replace("", NA) %>%
          .[!is.na(.)]) %>%
    purrr::map_chr(~ ifelse(length(.) > 0, str_c(., collapse = '&'), ""))
}

format_val <- function(val, is_pct = FALSE) {
  ifelse(!is.na(val),
         format(val, digits = 1) %>% str_c(ifelse(is_pct, "%", "")),
         NA)
}

split_sv_field <- function(.data, field, is_pct = FALSE) {
  # - separate field into two parts
  # - mutate to pct accordingly
  # - original field is mean of two parts
  f_q <- rlang::enquo(field)
  f_str <- rlang::quo_name(f_q)
  f1_str <- str_c(f_str, '1')
  f2_str <- str_c(f_str, '2')
  f1_q <- sym(f1_str)
  f2_q <- sym(f2_str)
  .data %>%
    tidyr::separate(!!f_q, c(f1_str, f2_str), sep = ",", fill = "right") %>%
    dplyr::mutate(
      !!f1_q := as.double(!!f1_q) * ifelse(is_pct, 100, 1),
      !!f2_q := as.double(!!f2_q) * ifelse(is_pct, 100, 1),
      !!f_q  := (!!f1_q + ifelse(is.na(!!f2_q), !!f1_q, !!f2_q)) / 2,
      !!f_q  := format_val(!!f_q, is_pct),
      !!f1_q := format_val(!!f1_q, is_pct),
      !!f2_q := format_val(!!f2_q, is_pct)
    )
}


sv_path <- params$somatic_sv
sv_unmelted <- NULL
sv_all <- NULL

if (length(readLines(con = sv_path, n = 2)) > 1) {
  sv_unmelted <-
    readr::read_tsv(sv_path, col_names = TRUE, col_types = "ccciiccccciiccccdc") %>%
    dplyr::select(-caller, -sample) %>%
    split_sv_field(BPI_AF, is_pct = TRUE) %>%
    split_sv_field(AF, is_pct = TRUE) %>%
    split_sv_field(CN) %>%
    split_sv_field(CN_change) %>%
    tidyr::separate(split_read_support, c("SR_ref", "SR_alt"), ",") %>%
    tidyr::separate(paired_support_PR, c("PR_ref", "PR_alt"), ",") %>%
    tidyr::separate(paired_support_PE, c("PE_ref", "PE_alt"), ",") %>%
    dplyr::mutate(SR = as.integer(SR_alt),
                  PR = as.integer(PR_alt),
                  PE = as.integer(PE_alt),
                  VarNum = dplyr::row_number())

  sv_all <- sv_unmelted %>%
    dplyr::filter(svtype != 'BND' | is.na(SR) | PR > SR) %>% # remove BND with split read support higher than paired
    tidyr::unnest(annotation = strsplit(annotation, ',')) %>% # unpack multiple annotations per region
    tidyr::separate(annotation, c('event', 'effect', 'genes', 'transcript', 'detail', 'tier'),
                    sep = '\\|', convert = TRUE) %>%  # Unpack annotation columns
    dplyr::arrange(tier, effect, desc(AF), genes) %>%
    dplyr::mutate(Gene = subset_genes(genes, c(1, 2)),
                  Gene = ifelse((str_split(genes, '&') %>% map_int(length)) > 2,
                                str_c(Gene, '...', sep = ', '),
                                Gene),
                  `Other affected genes` = subset_genes(genes, -c(1,2)) %>% str_replace_all('&', ', '),
                  Gene = ifelse(str_detect(effect, "gene_fusion"),
                                Gene,
                                Gene %>% str_replace_all('&', ', ')),
                  Transcript = transcript %>% str_replace_all('&', ', ')                  
                  ) %>%
    tidyr::separate(effect, c("Effect", "Other effects"), sep = '&', extra = "merge", fill = "right") %>%
    dplyr::mutate(start = format(start, big.mark = ',', trim = TRUE),
                  end = format(end, big.mark = ',', trim = TRUE),
                  location = str_c(chrom, ':', start, sep = ''),
                  location = ifelse(is.na(end), location, str_c(location)),
                  Ploidy = as.double(Ploidy),
                  Ploidy = format(Ploidy, nsmall = 2)
                  ) %>%
    dplyr::select(VarNum, Tier = tier, Event = svtype, Gene,
                  Effect = Effect, Detail = detail, Location = location,
                  AF, `CN chg` = CN_change,
                  SR, PR, CN, Ploidy, PURPLE_status,
                  SR_ref, PR_ref, PE, PE_ref,
                  SomaticScore = somaticscore, 
                  Transcript,
                  `Other effects`, `Other affected genes`,
                  AF_bp1 = AF1, AF_bp2 = AF2,
                  CN_bp1 = CN1, CN_bp2 = CN2,
                  CN_chg_bp1 = CN_change1, CN_chg_bp2 = CN_change2
                  ) %>%
    dplyr::distinct()

} else {
  sv_unmelted <- tibble(WARNING = "THERE WERE 0 SVs PRIORITISED!!")
  sv_all <- tibble(WARNING = "THERE WERE 0 SVs PRIORITISED!!")
}
```

```{r purple_qc_prep}
#---- PURPLE QC ----#
# read both datasets
qc_path <- params$purple_qc
purity_path <- params$purple_purity

purple_qc <-
  file.path(qc_path) %>%
  readr::read_tsv(col_names = c("key", "value"), col_types = "cc") %>%
  dplyr::mutate(value = toupper(value))
# turn into named vector
purple_qc <- structure(purple_qc$value, names = purple_qc$key)

purple_purity <-
  file.path(purity_path) %>%
  readr::read_tsv(col_types = cols(.default = col_double(),
                                   Gender = col_character(),
                                   Status = col_character())) %>%
  dplyr::mutate_if(is.numeric, round, 2) %>%
  unlist()

# sanity checks in case something changes between versions
nms_purple_qc <- c("QCStatus", "SegmentPass", "GenderPass", "DeletedGenesPass",
                   "SegmentScore", "UnsupportedSegments", "Ploidy",
                   "AmberGender", "CobaltGender", "DeletedGenes")
stopifnot(all(names(purple_qc) == nms_purple_qc))

nms_purple_purity <- c("#Purity", "NormFactor", "Score", "DiploidProportion", "Ploidy",
                       "Gender", "Status", "PolyclonalProportion", "MinPurity", "MaxPurity",
                       "MinPloidy", "MaxPloidy", "MinDiploidProportion", "MaxDiploidProportion",
                       "Version", "SomaticPenalty")
stopifnot(all(names(purple_purity) == nms_purple_purity))

# for shorter reference in glue
p <- purple_purity
q <- purple_qc
purple_qc_summary <- dplyr::tribble(
  ~Variable, ~value, ~details,
  'QC_Status', glue('{q["QCStatus"]}'), "",
  'Purity', glue('{p["#Purity"]} ({p["MinPurity"]}-{p["MaxPurity"]})'), "Purity of tumor",
  'Ploidy', glue('{p["Ploidy"]} ({p["MinPloidy"]}-{p["MaxPloidy"]})'), "Average ploidy of tumor sample (purity-adjusted)",
  'Gender', glue('{p["Gender"]}'), "",
  'Polyclonal Prop', p["PolyclonalProportion"], "Proportion of CN regions that are more than 0.25 from a whole copy number",
  'Diploidy Prop', glue('{p["DiploidProportion"]} ({p["MinDiploidProportion"]}-{p["MaxDiploidProportion"]})'), glue('Proportion of CN regions that have 1 (+- 0.2) minor and major allele'),
  'Segment_Pass', glue('{q["SegmentPass"]}'), glue('Score: {q["SegmentScore"]}; Unsupported: {q["UnsupportedSegments"]}'),
  'Gender_Pass', glue('{q["GenderPass"]}'), glue('Amber: {q["AmberGender"]}; Cobalt: {q["CobaltGender"]}'),
  'DelGenes_Pass', glue('{q["DeletedGenesPass"]}'), glue('count: {q["DeletedGenes"]}'),
  'Purple Version', p["Version"], "")
```

```{r purple_gene_cnv_prep}
#---- PURPLE Gene CNV Table ----#
key_genes <-
  readr::read_tsv(params$key_genes, col_types = cols(oncogene = "l", tumorsuppressor = "l")) %>%
  dplyr::select(symbol, oncogene, tumorsuppressor)

oncogenes <- key_genes %>% dplyr::filter(oncogene) %>% dplyr::pull(symbol)
tsgenes <- key_genes %>% dplyr::filter(tumorsuppressor) %>% dplyr::pull(symbol)

purple_gene_cnv <-
  readr::read_tsv(params$purple_gene_cnv, col_types = "ciicddcc") %>%
  dplyr::filter(Gene %in% key_genes$symbol) %>%
  dplyr::mutate(Chromosome = as.factor(Chromosome),
                oncogene = Gene %in% oncogenes,
                tsgene = Gene %in% tsgenes,
                role = dplyr::case_when(
                  oncogene & tsgene ~ "onco+ts",
                  oncogene ~ "oncogene",
                  tsgene ~ "tsgene",
                  TRUE ~ "")) %>%
  dplyr::select(gene = Gene,  minCN = MinCopyNumber, maxCN = MaxCopyNumber,
                chrom = Chromosome, start = Start, end = End,
                chrBand = ChromosomeBand, role)
```

```{r purple_global_cnv_prep}
#---- PURPLE Global CNV Table ----#
purple_global_cnv <- file.path(params$purple_cnv) %>%
  readr::read_tsv(col_types = "ciididdcccdddddd")

nms_purple_cnv <- c("#chromosome", "start", "end", "copyNumber", "bafCount", "observedBAF",
                    "baf", "segmentStartSupport", "segmentEndSupport", "method",
                    "depthWindowCount", "gcContent", "minStart", "maxStart", "minorAllelePloidy",
                    "majorAllelePloidy")

# keep track of column changes through PURPLE versions
stopifnot(all(names(purple_global_cnv) == nms_purple_cnv))

```

## Somatic Mutation Profiles

<a href="#top">Back to top</a>

### Allelic Frequencies
Summarised below are the allele frequencies (AFs) for somatic variants detected
genome-wide (__Global__) vs. within the coding sequence of ~1,100 UMCCR
cancer genes (__Key Genes CDS__).
AFs range from 0 to 1, or 0%-100% (we filter out all novel variants with AF < 10%).

<details>
<summary>Details</summary>

Variants are typically called in bcbio by 3 different callers, with calls supported by at least 2 of them used ("ensemble" approach).
In some cases only a single caller is used due to technical reasons (e.g. highly mutated FFPE sample).

The following post-processing steps occur:

1. `somatic_vcf_annotate`: [annotate VCF](https://github.com/umccr/vcf_stuff/blob/master/vcf_stuff/filtering/annotate_somatic_vcf.smk)
    against databases of known hotspots, germline variants, low mappability regions, UMCCR panel of normals
2. `somatic_vcf_filter`: [filter VCF](https://github.com/umccr/vcf_stuff/blob/master/scripts/filter_somatic_vcf)
    to remove germline variants and artefacts, but keep known hotspots
3. As preparation for the allelic frequencies plots:
    * `subset_to_giab`: keep variants in 'high confidence' regions as determined by the [Genome in a Bottle consortium](http://jimb.stanford.edu/giab/)
    * keep only variants with AF above 10%
4. Allele frequencies for global and keygenes:
    * `afs`: grab only the `INFO/TUMOR_AF` field and output to final txt file
    * `afs_keygenes`: grab the `CHROM`, `POS`, `ID`, `REF`, `ALT` and `INFO/TUMOR_AF`
      for variants in the UMCCR cancer gene BED file, and output to final txt file
</details>


```{r allele_freq_plot_stats}
ggplot(data = af_both, aes(af)) +
  geom_histogram(stat = 'bin', binwidth = 0.01, fill = "#006400") +
  facet_wrap(~set, scales = 'free_y', drop = FALSE) +
  scale_x_continuous(name = "Allele Frequency",
                     breaks = seq(0, 1, by = 0.1),
                     limits = c(0, 1), expand = c(0, 0)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
        panel.grid.minor = element_blank()) +
  labs(title = paste("AF count distribution"))

af_stats %>%
  knitr::kable(format = "html", caption = "AF Summary Stats") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left") %>%
  kableExtra::column_spec(1, bold = TRUE)
```

### Mutational Signatures {.tabset .tabset-fade}

<a href="#top">Back to top</a>

Deciphering the mutational signature of a tumor sample can provide insight into the mutational
processes involved in carcinogenesis and help in cancer treatment and prevention.
The [MutationalPatterns](http://bioconductor.org/packages/release/bioc/html/MutationalPatterns.html)
R package is used to generate a mutation signature for the sample. We use the final filtered somatic
calls as input.

#### Context signature

```{r plot_96_prof, out.height="50%"}
MutationalPatterns::plot_96_profile(mut_mat, condensed = TRUE)
```

#### Point mutation spectrum

<details>
<summary>Description</summary>

We can count the mutation type occurrences for the input VCF.
For `C>T` mutations, a distinction is made between `C>T` at CpG sites
and other sites, as deamination of methylated cytosine at CpG sites is a common mutational
process. This is the reason the reference genome is needed.

A mutation spectrum shows the relative contribution of each mutation type in the base
substitution catalogs. We can plot the mean relative contribution of
each of the 6 base substitution types over all samples. Error bars indicate standard deviation
over all samples. The total number of mutations is indicated. We can also distinguish
between `C>T` at CpG sites and other sites.

</details>

```{r plot_mut_type_occurrences, out.height="50%"}
type_occurrences <- mut_type_occurrences(vcf_list = somatic_snv, ref_genome = ref_genome)
plot_spectrum(type_occurrences, CT = TRUE)
```

#### Transcriptional strand bias

<details>
<summary>Description</summary>

We can determine if a gene mutation is on the transcribed or non-transcribed
strand, which can be used to evaluate the involvement of transcription-coupled
repair. By convention base substitutions are regarded as C>X or T>X, so we try
to determine whether the C or T base is on the same strand as the gene
definition. Base substitutions on the same strand as the gene definition are
considered 'untranscribed', and on the opposite strand 'transcribed', since the
gene definitions report the coding or sense strand, which is untranscribed. No
strand information is reported for base substitutions that overlap with more
than one gene on different strands.

</details>

```{r tran_strand_bias, out.height="50%"}
# Get known genes table from UCSC
if (params$genome_build == 'hg19') {
  genes_list <- genes(TxDb.Hsapiens.UCSC.hg19.knownGene)
} else {
  genes_list <- genes(TxDb.Hsapiens.UCSC.hg38.knownGene)
}

# Mutation count matrix with strand info (4*6*4=96 -> 96*2=192)
mut_mat_s <- MutationalPatterns::mut_matrix_stranded(somatic_snv,
                                                     ref_genome = ref_genome,
                                                     ranges = genes_list,
                                                     mode = "transcription")

# Mutation count per type and strand
strand_counts <- MutationalPatterns::strand_occurrences(mut_mat_s, by = "all")
# Poisson test for strand asymmetry significance testing
strand_bias <- MutationalPatterns::strand_bias_test(strand_counts)

# mutation spectrum with strand distinction
MutationalPatterns::plot_strand(strand_counts, mode = "relative")
# effect size of strand bias
MutationalPatterns::plot_strand_bias(strand_bias)
```

#### Replicative strand bias

<details>
<summary>Description</summary>

The involvement of replication-associated mechanisms can be evaluated by
testing for a mutational bias between the leading and lagging strand.
The replication strand is dependent on the locations of replication
origins from which DNA replication is fired.
However, replication timing is dynamic and cell-type specific,
which makes replication strand determination less straightforward than
transcriptional strand bias analysis.
Replication timing profiles can be generated with
Repli-Seq experiments. Once the replication direction is defined,
a strand asymmetry analysis can be performed similarly as the transcription
strand bias analysis.

</details>

```{r rep_strand_bias, out.height="50%"}
repli_file <- system.file("extdata/ReplicationDirectionRegions.bed",
                          package = "MutationalPatterns")
# start/stop contain scientific notation, so need to be doubles
repli_strand <-
  readr::read_tsv(repli_file, col_names = TRUE, col_types = "cddcc") %>%
  dplyr::mutate_if(is.character, as.factor)
repli_strand_granges <- GRanges(
  seqnames = repli_strand$Chr,
  ranges = IRanges(start = repli_strand$Start + 1,
                   end = repli_strand$Stop),
  strand_info = repli_strand$Class)

seqlevelsStyle(repli_strand_granges) <- seqlevelsStyle(base::get(ref_genome))

mut_mat_s_rep <-
  MutationalPatterns::mut_matrix_stranded(
    vcf_list = somatic_snv,
    ref_genome = ref_genome,
    ranges = repli_strand_granges,
    mode = "replication")
# Mutation count per type and strand
strand_counts_rep <- strand_occurrences(mut_mat_s_rep, by = "all")
# Poisson test for strand asymmetry significance testing
strand_bias_rep <- strand_bias_test(strand_counts_rep)

MutationalPatterns::plot_strand(strand_counts_rep, mode = "relative")
MutationalPatterns::plot_strand_bias(strand_bias_rep)
```

### Signature Contribution

<a href="#top">Back to top</a>

<details>
<summary>Description</summary>

The contribution of any set of signatures to the mutational profile of a
sample can be quantified. This unique feature is specifically useful
for mutational signature analyses of small cohorts or individual samples,
but also to relate own findings to known signatures and published findings.
The `fit_to_signatures` function finds the optimal linear combination of
mutational signatures that most closely reconstructs
the mutation matrix by solving a non-negative least-squares constraints problem.

Shown are signatures with positive Contribution values, along with summarised descriptions
and reference signature plots from <https://cancer.sanger.ac.uk/cosmic/signatures>.

</details>

```{r mutational_signature_contribution}
sig_table <-
  readr::read_tsv(file = "misc/sig/signatures_description.tsv", col_types = "cc") %>%
  dplyr::mutate(Plot = paste0("![](misc/sig/img/sig-", signature, ".png)"),
                signature = paste0("Sig", signature)) %>%
  dplyr::select(Signature = signature, Description = description, Plot)

mut_sig_contr %>%
  dplyr::left_join(sig_table, by = "Signature") %>%
  knitr::kable() %>%
  kableExtra::kable_styling(font_size = 12) %>%
  kableExtra::scroll_box(height = "500px")
```

### Rainfall Plots {.tabset .tabset-fade}

<a href="#top">Back to top</a>

Rainfall plots are used to visualize the distribution of mutations along the genome,
including mutation types.

#### Rainfall

<details>
<summary>Description</summary>

Rainfall plot. The y-axis corresponds to the distance of a mutation from the previous mutation,
and is log10 transformed. Drop-downs from the plots indicate clusters or
"hotspots" of mutations.
</details>

```{r rainfall, out.height="95%"}
chromosomes <- seqnames(get(ref_genome))[1:22]
MutationalPatterns::plot_rainfall(somatic_snv[[1]], chromosomes = chromosomes, cex = 1.2, ylim = 1e+09)
```

#### Circos

<details>
<summary>Description</summary>

Somatic SNVs/Indels, Total/Minor CN, SVs

Generated from PURPLE.

* __Track1__: Chromosomes. Darker shaded areas: gaps in reference genome
  (centromeres, heterochromatin & missing short arms)
* __Track2__: Somatic variants (incl. exon, intron and intergenic regions).
    * outer ring: SNP allele frequencies, corrected for tumor purity and scaled from 0 to 100%.
      Each dot represents a single somatic variant, coloured according to the
      type of base change (e.g. C>T/G>A in red).
    * inner ring: short insertion (yellow) and deletion (red) locations.
* __Track3__: Observed __total__ copy number changes adjusted for tumor purity,
  including focal and chromosomal somatic events.
  <span style="color:red">Red</span> = Loss; <span style="color:#32CD32">Green</span> = Gain.
  Scaled from 0 (complete loss) to 6 (high level gains).
  If > 6, shown as 6 with a green dot on the outermost green gridline.
* __Track4__: Observed __minor__ allele copy numbers. Range from 0 to 3.
  Expected normal minor allele copy number is 1, and anything below 1 is shown
  as a loss (<span style="color:#EE7600">Orange</span>), representing an LOH event.
  Minor allele copy numbers above 1 (<span style="color:#7EC0EE">Blue</span>) indicate gains
  of both A and B alleles.
* __Track5__ (Inner circle): Observed structural variants within or between the chromosomes.
    * <span style="color:#7EC0EE">Blue</span> = Translocations
    * <span style="color:red">Red</span> = Deletions
    * <span style="color:#e6e600">Yellow</span> = Insertions
    * <span style="color:#32CD32">Green</span> = Tandem duplications
    * <span style="color:#000000">Black</span> = Inversions

</details>

```{r circos_default1, out.width="80%"}
img_dir <- file.path('img') # created before when copying purple files to tmp dir
knitr::include_graphics(file.path(img_dir, paste0(params$batch_name, '.circos.png')))
```



## Structural Variants

<a href="#top">Back to top</a>

Structural variants are inferred with [Manta](https://github.com/illumina/manta),
adjusted using [PURPLE](https://github.com/hartwigmedical/hmftools/tree/master/purity-ploidy-estimator#7-structural-variant-recovery-and-single-breakend-filtering),
and prioritised using [simple_sv_annotation](https://github.com/AstraZeneca-NGS/simple_sv_annotation).

Allele frequencies, copy number changes and ploidy are purity-adjusted.

<details>
<summary>Details</summary>

The input file corresponds to `umccrised/<batch>/structural/<batch>-manta.tsv`.

It's generated through the following steps:

1. Call variants with manta SV caller
2. Filter:
   * require split or paired reads support at least 5x,
   * for low frequency variants (<10% at both breakpoints), require read support 10x,
   * require paired reads support to be higher than split read support for BND events
3. Annotate with [SnpEff](http://snpeff.sourceforge.net/SnpEff_manual.html) based on Ensembl gene model
4. Subset annotations to [APPRIS principal transcripts](http://appris.bioinfo.cnio.es/#/)
5. Prioritize variants with [simple_sv_annotation](https://github.com/vladsaveliev/simple_sv_annotation) 1(high)-2(moderate)-3(low)-4(no interest):

    * exon loss
       - on prioritisation gene list (1)
       - other (2)
    * gene_fusion
       - paired (hits two genes)
          - on list of known pairs (1) (curated by [HMF](https://resources.hartwigmedicalfoundation.nl))
          - one gene is a known promiscuous fusion gene (1) (curated by [HMF](https://resources.hartwigmedicalfoundation.nl))
          - on list of FusionCatcher known pairs (2)
          - other:
             - one or two genes on prioritisation gene list (2)
             - neither gene on prioritisation gene list (3)
       - unpaired (hits one gene)
           - on prioritisation gene list (2)
           - others (3)
    * upstream or downstream
       - on prioritisation gene list genes (2)  - e.g. one gene is got into control of another gene's promoter and get overexpressed (oncogene) or underexpressed (tsgene)
    * LoF or HIGH impact in a tumor suppressor
       - on prioritisation gene list (2)
       - other TS gene (3)
    * other (4)

6. Use PURPLE copy number caller to infer more SV calls from copy number transitions (marked as "From_CNV")

Variants are ordered by tier, then by effect, then by AF.


* __Column Description__

- `Ploidy`: variant ploidy (purity-adjusted )
- `AF`: allele frequency at each breakend (`AF_bp1`, `AF_bp2`) and averaged (`AF`) (purity-adjusted)
- `CN`: copy number at each breakend (`CN_bp1`, )
- `CN_change`: change in copy number at each breakend (`CN_chg_bp1`, `CN_chg_bp2`) and averaged (`CN chg`) (purity-adjusted)
- `Effect`: can contain any effect predicted by [SnpEff](http://snpeff.sourceforge.net/SnpEff_manual.html#input),
  with standardised terms from [Sequence ontology](http://www.sequenceontology.org).

</details>

```{r sv_prioritize_table}
sv_all %>%
  DT::datatable(rownames = FALSE, extensions = c('Scroller', 'Responsive', 'Buttons'),
                options = list(scroller = TRUE, scrollX = FALSE, scrollY = 500,
                               dom = 'Bfrtip', buttons = c('csv', 'excel')))
```

## Copy Number Variants

<a href="#top">Back to top</a>

The purity and ploidy estimator
[PURPLE](https://github.com/hartwigmedical/hmftools/tree/master/purity-ploidy-estimator)
is used to generate a copy number profile for the somatic sample.

### QC, Purity and Ploidy Summary

PURPLE outputs a QC status along with a summary
for the inferred purity and ploidy of the somatic sample.
A failed QC status can be attributed to several factors
(see `Description` below).

<details>
<summary>Description</summary>

__QC Failure__

There are several reasons PURPLE may classify a sample as failed:

* `FAIL_SEGMENT`: more than 120 copy number segments __not__ supported at either end
  by SV breakpoints. Indicates samples with extreme GC bias, with differences
  in depth of >= 10x between high and low GC regions. GC normalisation is
  unreliable when the corrections are so extreme so it is recommended to fail
  the sample (concerns with miscalled deletions or amplifications or have
  poor sensitivity in high GC regions.
* `NO_TUMOR`: no aneuploidy found and the number of somatic SNVs found is
  less than 1,000
* `MIN_PURITY`: fitted purity < 20%
* `FAIL_DELETED_GENES`: more than 280 deleted genes. This QC step was added
  after observing that in a handful of samples with high MB scale positive GC
  bias we sometimes systematically underestimate the copy number in high GC
  regions. This can lead us to incorrectly infer homozygous loss of entire
  chromosomes, particularly on chromosome 19.
* `FAIL_GENDER`: if the AMBER and COBALT inferred genders are inconsistent
  then the COBALT one is used but the sample is failed.

</details>


```{r purple_qc_summary}
purple_qc_summary %>%
  dplyr::mutate(
    Variable = kableExtra::cell_spec(Variable, bold = TRUE),
    value = kableExtra::cell_spec(value, bold = TRUE,
                                  color = dplyr::case_when(
                                    value == "PASS" ~ "green",
                                    grepl("FAIL", value) ~ "red",
                                    value == "FEMALE" ~ "purple",
                                    value == "MALE" ~ "blue",
                                    value == "MALE_KLINEFELTER" ~ "red",
                                    value == "TRUE" ~ "green",
                                    value == "FALSE" ~ "red",
                                    TRUE ~ "black"))) %>%
  knitr::kable(escape = FALSE, caption = "QC, Purity & Ploidy Summary") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left")
```

### Circos {.tabset .tabset-fade}

<a href="#top">Back to top</a>

#### Plot 1: Total/Minor CN, SVs, BAF

<details>
<summary>Description</summary>

* __Track1__: Chromosomes
* __Track2__: <span style="color:#8A2BE2">Beta Allele Frequency</span>
* __Track3__: Total Copy Number Changes (see above)
* __Track4__: Minor Copy Number Changes (see above)
* __Track5__ (Inner circle): Observed Structural Variants (see above)

</details>

```{r circos_baf_plot, out.width="80%"}
knitr::include_graphics(file.path(img_dir, paste0(params$batch_name, '.circos_baf.png')))
```

#### Plot 2: Tumor/Normal Allele Ratios, BAF

<details>
<summary>Description</summary>

* __Track1__: Chromosomes. Darker shaded areas: gaps in reference genome
  (centromeres, heterochromatin & missing short arms)
* __Track2__: <span style="color:blue">Tumor</span> and <span style="color:#32CD32">Normal</span> Ratios
* __Track3__: <span style="color:#EE7600">Beta Allele Frequency</span>

</details>


```{r circos_default2, out.width="80%"}
knitr::include_graphics(file.path(img_dir, paste0(params$batch_name, '.input.png')))
```

### UMCCR Gene CNV Calls

<a href="#top">Back to top</a>

<details>
<summary>Description</summary>

PURPLE outputs a file with copy number values per gene. Here, we include only
the below information for ~1,100 genes in the UMCCR Cancer Gene list.

* `Gene`: gene name
* `Min/MaxCN`: minimum/maximum copy number within the entire gene
* `Chr`, `Start`, `End`: gene coordinates
* `ChrBand`: chromosome band
* `Role`: oncogene ('oncogene'), tumor suppressor ('tsgene'), or both ('onco+ts'),
   as reported by [Cancermine](https://github.com/jakelever/cancermine)
* `TxID`: Ensembl Transcript ID

</details>


```{r purple_gene_cnv_tab}
purple_gene_cnv %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                rownames = FALSE, extensions = c("Scroller", "Buttons"),
                options = list(scroller = TRUE, scrollX = TRUE, scrollY = 400,
                               buttons = c('csv', 'excel'), dom = 'Bfrtip')) %>%
  DT::formatCurrency(~ start + end, currency = "", interval = 3, mark = ",", digits = 0) %>%
  DT::formatRound(~ minCN + maxCN, digits = 1)
```

### Genome-wide CNV Segments

<a href="#top">Back to top</a>

<details>
<summary>Description</summary>

PURPLE outputs a file with the copy number profile of all contiguous segments
of the tumor sample:

* `CN`:  Fitted absolute copy number of segment adjusted for purity and ploidy
* `Ploidy Min+Maj`: Ploidy of minor + major allele adjusted for purity
* `BAF`: Tumor BAF after adjusted for purity and ploidy
* `BafCount`: Count of AMBER baf points covered by this segment
* `SegSupport`: Type of SV support for the CN breakpoint at start/end of region.
  Allowed values: `CENTROMERE`, `TELOMERE`, `INV`, `DEL`, `DUP`, `BND` (translocation),
  `SGL` (single breakend SV support), `NONE` (no SV support for CN breakpoint),
  `MULT` (multiple SV support at exact breakpoint)
* `Method`: Method used to determine the CN of the region.
  Allowed values: `BAF_WEIGHTED` (avg of all depth windows for the region),
  `STRUCTURAL_VARIANT` (inferred using ploidy of flanking SVs),
  `LONG_ARM` (inferred from the long arm),
  `GERMLINE_AMPLIFICATION` (inferred using special logic to handle
  regions of germline amplification)
* `windowCount`: Count of COBALT windows covered by this segment
* `GC`: Proportion of segment that is G or C


Summary of the CNV segments:

```{r purple_cnv_segs_summary}
purple_global_cnv %>%
  dplyr::rename(chrom = `#chromosome`, tot_cn = copyNumber) %>%
  dplyr::select(chrom, start, end, tot_cn) %>%
  dplyr::mutate(seg_len = end - start) %>%
  dplyr::summarise(n = n(),
                   mean_len = round(mean(seg_len), 0),
                   med_len = round(median(seg_len), 0),
                   min_cn = round(min(tot_cn), 2),
                   max_cn = round(max(tot_cn), 2)) %>%
  knitr::kable(format.args = list(big.mark = ",")) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left")
```



</details>

```{r purple_global_cnv_tab}
purple_global_cnv %>%
  dplyr::mutate(Chrom = as.factor(`#chromosome`),
                minorAllelePloidy = round(minorAllelePloidy, 1),
                majorAllelePloidy = round(majorAllelePloidy, 1),
                `Ploidy Min+Maj` = paste0(minorAllelePloidy, "+", majorAllelePloidy),
                copyNumber = round(copyNumber, 1),
                bafAdj = round(baf, 2),
                gcContent = round(gcContent, 2),
                `Start/End SegSupport` = paste0(segmentStartSupport, "-", segmentEndSupport),
                `BAF (count)` = paste0(bafAdj, " (", bafCount, ")"),
                `GC (windowCount)` = paste0(gcContent, " (", depthWindowCount, ")")) %>%
  dplyr::select(Chrom, Start = start, End = end, CN = copyNumber, `Ploidy Min+Maj`,
                `Start/End SegSupport`, Method = method, `BAF (count)`, `GC (windowCount)`) %>%
  DT::datatable(filter = list(position = "top", clear = FALSE, plain = TRUE),
                rownames = FALSE, extensions = c("Scroller", "Buttons"),
                options = list(scroller = TRUE, scrollX = TRUE, scrollY = 400,
                               buttons = c('csv', 'excel'), dom = 'Bfrtip')) %>%
  DT::formatCurrency(~ Start + End, currency = "", interval = 3, mark = ",", digits = 0)
```

## Software Versions

<a href="#top">Back to top</a>

```{r um_version}
umv <- "unavailable"
if (Sys.which("umccrise") != "") {
  umv <- system("umccrise --version", intern = TRUE) %>%
    sub("umccrise, version (.*)", "\\1", .)
}

```


<details>
<summary>Summary</summary>

* umccrise: __`r umv`__

* R Session Info:

```{r session_info}
si <- devtools::session_info(include_base = TRUE)
si_pl <- unclass(si$platform) %>% as_tibble() %>% t()
si_pkg <- unclass(si$packages) %>%
  dplyr::as_tibble() %>%
  dplyr::select(package, version = ondiskversion, path, datestamp = date)



dplyr::tibble(var = row.names(si_pl),
              value = si_pl[, , drop = TRUE]) %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left") %>%
  kableExtra::column_spec(1, bold = TRUE)

knitr::kable(si_pkg, format = "html") %>%
  kableExtra::kable_styling(full_width = TRUE, position = "left") %>%
  kableExtra::column_spec(1, bold = TRUE) %>%
  kableExtra::scroll_box(height = "400px")
```

</details>

