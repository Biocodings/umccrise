'''
Somatic calls
-------------
Run ensemble and raw calls through PCGR and combine with the cnv calls.
'''
from umccrise import panel_of_normals


rule panel_of_normals:
    input:
        vcf = lambda wc: join(run.date_dir, f'{batch_by_name[wc.batch].name}-ensemble-annotated.vcf.gz'),
        toml = join(loc.panel_of_normals_dir, 'annotate_normals_vcfanno.toml'),
        lua = join(loc.panel_of_normals_dir, 'code.lua')
    params:
        ht = 1,
        normals_dir = loc.panel_of_normals_dir
    output:
        'umccrised/{batch}/somatic/ensemble-pon.vcf.gz'
    shell:
        'vcfanno -lua {input.lua}'
        ' <(sed s#file=\\\"#file=\\\"{params.normals_dir}/# {input.toml})'
        ' {input.vcf} |'
        ' bcftools filter -e "INFO/PoN_CNT>={params.ht}" --soft-filter PoN --mode + -Oz -o {output}'
        ' && tabix -p vcf {output}'


# PCGR struggles with anything but the basic chromosome setup. It also ignores any variant not marked `PASS` so might as well remove others to save on transfer times:
rule pcgr_somatic_vcf:
    input:
        rules.panel_of_normals.output[0]
    output:
        vcf = 'umccrised/{batch}/somatic/pcgr/ensemble.vcf.gz',
        tbi = 'umccrised/{batch}/somatic/pcgr/ensemble.vcf.gz.tbi'
    shell:
        'pcgr_prep {input} |'
        ' bcftools view -f.,PASS -t 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X,Y -Oz -o {output.vcf}'
        ' && tabix -p vcf {output.vcf}'


# PCGR also wants a slightly different format for the CNS data:
rule pcgr_cns:
    input:
        lambda wc: join(batch_by_name[wc.batch].tumor.dirpath, f'{batch_by_name[wc.batch].name}-cnvkit.cns')
    output:
        'umccrised/{batch}/somatic/pcgr/cnvkit-pcgr.tsv'
    shell:
        'echo -e "Chromosome\\tStart\\tEnd\\tSegment_Mean" > {output} && cat {input} | grep -v ^chromosome | cut -f 1,2,3,5 >> {output}'


## Allelic frequencies
# AF is not yet integrated into PCGR or CGI. We can extract those from Mutect2 for plotting purposes, but still need to look up AF for genes of interest manually. Not entirely ideal but for a rough summary plot but this is going to be sufficient. Can revisit once we've unified AF information across callers:

rule afs:
    input:
        vcfs = lambda wc: expand(join(run.date_dir, f'{batch_by_name[wc.batch].name}-{{caller}}-annotated.vcf.gz'), caller=list(batch_by_name.values())[0].tumor.variantcallers)
    params:
        tumor_name = lambda wc: batch_by_name[wc.batch].tumor.name
    output:
        'umccrised/{batch}/somatic/af/af_tumor.txt'
    run:
        af_vcf = next((vcf for vcf in input.vcfs if vcf.endswith('-vardict-annotated.vcf.gz')), None)
        if not af_vcf:
            print('could not find VarDict VCF, falling back to Mutect2')
            af_vcf = next((vcf for vcf in input.vcfs if vcf.endswith('-mutect2-annotated.vcf.gz')), None)
        shell('bcftools view -f .,PASS ' + af_vcf + ' -s {params.tumor_name} -Ou | bcftools query -f "[%AF]\\n" > {output}')

rule afs_az300:
    input:
        vcfs = lambda wc: expand(join(run.date_dir, f'{batch_by_name[wc.batch].name}-{{caller}}-annotated.vcf.gz'), caller=list(batch_by_name.values())[0].tumor.variantcallers),
        az300 = az300
    params:
        tumor_name = lambda wc: batch_by_name[wc.batch].tumor.name
    output:
        'umccrised/{batch}/somatic/af/af_tumor_az300.txt'
    run:
        af_vcf = next((vcf for vcf in input.vcfs if vcf.endswith('-vardict-annotated.vcf.gz')), None)
        if not af_vcf:
            print('could not find VarDict VCF, falling back to Mutect2')
            af_vcf = next((vcf for vcf in input.vcfs if vcf.endswith('-mutect2-annotated.vcf.gz')), None)
        shell('bcftools view -f .,PASS ' + af_vcf + ' -s {params.tumor_name} -Ov'
              ' | bedtools intersect -a stdin -b {input.az300} -header'
              ' | bcftools query -f "%CHROM\\t%POS\\t%ID\\t%REF\\t%ALT\\t[%AF]\\t%INFO/ANN\n" > {output}')

# Generating the plot manually at a later stage.


rule somatic:
    input:
        expand([
            rules.afs_az300.output[0],
            rules.afs.output[0],
            rules.pcgr_somatic_vcf.output[0],
            rules.pcgr_cns.output[0]],
        batch=batch_by_name.keys())
    output:
        'umccrised/.snakemake/somatic.done'
    shell:
        'touch {output}'

