""" UMCCR post-bcbio patient analysis workflow
"""
import os
from os.path import join, abspath, dirname
from ngs_utils.file_utils import splitext_plus
from ngs_utils.bcbio import BcbioProject
from ngs_utils.file_utils import add_suffix, get_ungz_gz
from umccrise.utils import get_loc, get_sample_name
from umccrise.patient_analysis import get_sig_rmd_file

threads_max = 32        # Use up to 32 cores at once, if available
cov_by_phenotype = config.get('cov_by_phenotype', {'tumor': 30, 'normal': 10})  # For goleft regions coverage, use minimum coverage 10 for normal, 30 for tumor

az300 = join(get_loc().hsapiens, 'GRCh37/coverage/prioritize/cancer/az300.bed.gz')
ref_fa = join(get_loc().hsapiens, 'GRCh37/seq/GRCh37.fa')
extras = get_loc().extras

run = BcbioProject(config.get('run_dir', abspath(os.getcwd())))  
batch_by_name = run.batch_by_name
if 'batch' in config:
    batch_by_name = {k: v for k, v in batch_by_name.items() if k == config['batch']}


rule all:
    input:
        expand(
         expand(['umccrised/{{batch}}/coverage/{phenotype}.callable.bed', 
                 'umccrised/{{batch}}/igv/{phenotype}_mini.bam',
                ], phenotype=['tumor', 'normal']) +
          expand('umccrised/{{batch}}/somatic/pcgr/{caller}.vcf.gz', 
                  caller=list(batch_by_name.values())[0].tumor.variantcallers) +
                ['umccrised/{batch}/coverage/indexcov/index.html',
                 'umccrised/{batch}/somatic/pcgr/cnvkit-pcgr.tsv',
                 'umccrised/{batch}/somatic/rstudio/ensemble-ucsf.vcf',
                 'umccrised/{batch}/somatic/rstudio/sig.html',
                 'umccrised/{batch}/germline/pcgr/ensemble-cancer.vcf.gz',
                 'umccrised/{batch}/af/af_vardict_tumor.txt',
                 'umccrised/{batch}/af/af_vardict_tumor_az300.txt',
                 'umccrised/{batch}/structural/cnvkit-nolabels-diagram.pdf',
                 'umccrised/{batch}/structural/manta.bed',
                 'umccrised/{batch}/structural/sv-prioritize-manta.bedpe',
                ], batch=batch_by_name.values()
        ) + ['umccrised/qc/multiqc_report.html', 
             'umccrised/log/data_versions.csv',
             'umccrised/log/programs.txt',
             'umccrised/log/config']


rule rmd:
    input:
        expand('umccrised/{batch}/somatic/rstudio/sig.html', batch=batch_by_name.values())


rule symlink_multiqc:
    input:
        join(run.date_dir, 'multiqc/multiqc_report.html')
    output:
        'umccrised/qc/multiqc_report.html'
    shell:
        'ln -s {input} {output}'


## Cancer gene coverage
# Looking at coverage for a limited set of (cancer) genes to assess overall reliability. 
# Minimum coverage for normal is 10, 30 for cancer.
rule coverage:
    input:
        bam = lambda wc: getattr(batch_by_name[wc.batch], wc.phenotype).bam,
        az300 = az300,
        ref_fa = ref_fa
    params:
        prefix = lambda wc, output: output[0].replace('.callable.bed', ''),
        cutoff = lambda wc: cov_by_phenotype[wc.phenotype]
    output:
        'umccrised/{batch}/coverage/{phenotype}.callable.bed'
    threads: threads_max
    shell:
        'goleft depth {input.bam} --reference {ref_fa} --processes {threads} --bed {az300} --stats --mincov {params.cutoff} --prefix {params.prefix}'


# Also bringing in global coverage plots for review (tumor only, quick check for CNVs):
rule cov_plots:
    input:
        bam = lambda wc: batch_by_name[wc.batch].tumor.bam
    params:
        directory = 'umccrised/{batch}/coverage/indexcov'
    output:
        'umccrised/{batch}/coverage/indexcov/index.html'
    shell:
        'goleft indexcov --directory {params.directory} {input.bam}'


## Somatic calls
# Run ensemble and raw calls through PCGR and combine with the cnv calls:

# PCGR struggles with anything but the basic chromosome setup. It also ignores any variant not marked `PASS` so might as well remove others to save on transfer times:
rule pcgr_vcf:
    input:
        vcf = join(run.date_dir, '{batch}-{caller}-annotated.vcf.gz')
    output:
        'umccrised/{batch}/somatic/pcgr/{caller}.vcf.gz'
    shell:
        'bcftools view -f .,PASS -r 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X,Y {input.vcf} -Oz > {output}'

# PCGR also wants a slightly different format for the CNS data:
rule pcgr_cns:
    input:
        lambda wc: join(batch_by_name[wc.batch].tumor.dirpath, f'{wc.batch}-cnvkit.cns')
    output:
        'umccrised/{batch}/somatic/pcgr/cnvkit-pcgr.tsv'
    shell:
        'echo -e "Chromosome\\tStart\\tEnd\\tSegment_Mean" > {output} && cat {input} | grep -v ^chromosome | cut -f 1,2,3,5 >> {output}'


# Ensemble calls to be submitted to CGI. Sharing functionality does not seem to work at this point. Ensemble calls only include variants that `PASS` so no additional filtering required.
# Finally, for the local analysis with MutationalPatterns generate UCSC-versions of the ensemble calls:
rule cgi:
    input:
        'umccrised/{batch}/somatic/pcgr/ensemble.vcf.gz'
    output:
        'umccrised/{batch}/somatic/rstudio/ensemble-ucsf.vcf'
    shell:
        'cat {input}'
        ' | awk \'{{ if($0 !~ /^#/) print "chr"$0; else if(match($0,/(##contig=<ID=)(.*)/,m)) print m[1]"chr"m[2]; else print $0 }}\''
        ' | grep -v chrG > {output}'
# All done; file needs to be submitted to CGI and PCGR manually for now. 


## Allelic frequencies
# AF is not yet integrated into PCGR or CGI. We can extract those from VarDict or FreeBayes for plotting purposes, but still need to look up AF for genes of interest manually. Not entirely ideal but for a rough summary plot but this is going to be sufficient. Can revisit once we've unified AF information across callers:

rule af_freqs:
    input:
        vcf = join(run.date_dir, '{batch}-vardict-annotated.vcf.gz')
    params:
        tumor_name = lambda wc: batch_by_name[wc.batch].tumor.name
    output:
        'umccrised/{batch}/af/af_vardict_tumor.txt'
    shell:
        'bcftools view -f .,PASS {input.vcf} -s {params.tumor_name} -Ou'
        ' | bcftools query -f "[%AF]\\n" > {output}'

rule af_freqs_az300:
    input:
        vcf = join(run.date_dir, '{batch}-vardict-annotated.vcf.gz'),
        az300 = az300
    params:
        tumor_name = lambda wc: batch_by_name[wc.batch].tumor.name
    output:
        'umccrised/{batch}/af/af_vardict_tumor_az300.txt'
    shell:
       'bcftools view -f .,PASS {input.vcf} -s {params.tumor_name} -Ov'
        ' | bedtools intersect -a stdin -b {input.az300} -header'
        ' | bcftools query -f "%CHROM\\t%POS\\t%ID\\t%REF\\t%ALT\\t[%AF]\\t%INFO/ANN\n" > {output}'

# Generating the plot manually at a later stage.

## Germline summary
# Take a single germline call set (or preferably the ensemble best practice calls, if generated) and annotate any events found in Sean's 105/106 cancer predisposition gene set.
# Note: need to store that cancer gene list somewhere. Happy to add to bcbio directly but then need source information.

rule prep_germline:
    input:
        vcf = join(run.date_dir, '{batch}-ensemble-annotated.vcf.gz'),
        ensg = join(extras, 'cancer_genes_ENSG.txt')
    output:
        'umccrised/{batch}/germline/germline-ensemble-cancer.vcf.gz'
    params:
        ungz = lambda wc, output: get_ungz_gz(output[0])[0]
    shell:
        'zgrep ^# {input.vcf} > {params.ungz} && '
        'zgrep -f {input.ensg} {input.vcf} >> {params.ungz} && '
        'bgzip {params.ungz} && tabix {output}'

# Prepare it for submission to PCGR
rule pcgr_germline:
    input:
        vcf = rules.prep_germline.output[0]
    output:
        'umccrised/{batch}/germline/pcgr/ensemble-cancer.vcf.gz',
    shell:
        'bcftools view -f .,PASS -r 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X,Y {input.vcf} -Oz > {output}'

# Can review the `.txt` file in Excel or submit the VCF to frameworks such as [gene.iobio](http://gene.iobio.io/). 

## Structural changes
# Re-do the CNV plots. This will need lots of love (drop gene names, make the scatterplot viable again, etc.).

# Remove gene labels
rule cnvkit_cleanup:
    input:
        lambda wc: join(batch_by_name[wc.batch].tumor.dirpath, f'{wc.batch}-cnvkit.cns')
    output:
        'umccrised/{batch}/structural/cnvkit-nolabels.cns'
    shell:
        '{{'
        ' head -n1 {input}'
        ' ; '
        'grep -v ^chromosome {input} | awk -v OFS=\'\\t\' \'{{ print $1, $2, $3, "", $5, $6, $7, $8 }}\''
        ' ; '
        '}} > {output}'

# Plot
rule cnvkit_plot:
    input:
        rules.cnvkit_cleanup.output[0]
    output:
        'umccrised/{batch}/structural/cnvkit-nolabels-diagram.pdf'
    shell:
        'cnvkit.py diagram -s {input} -o {output}'

# Bring in the prioritized SV calls from Manta. This will change with the inclusion of BPI and should also include a basic plot at some stage.
rule get_manta:
    input:
        lambda wc: join(batch_by_name[wc.batch].tumor.dirpath, f'{wc.batch}-sv-prioritize.tsv')
    output:
        'umccrised/{batch}/structural/sv-prioritize-manta.tsv'
    shell:
        'grep manta {input} > {output}'

# At least for the (most conservative) manta calls generate a file for viewing in Ribbon:
rule ribbon:
    input:
        fai = ref_fa + '.fai',
        manta_vcf = lambda wc: join(batch_by_name[wc.batch].tumor.dirpath, f'{wc.batch}-sv-prioritize-manta.vcf.gz')
    output:
        'umccrised/{batch}/structural/manta.bed'
    params:
        vcftobedpe = 'python2 ' + join(extras, 'svtools-master/vcfToBedpe')
    shell:
        '{{ '
        'bcftools view -f .,PASS {input.manta_vcf}'
        ' | {params.vcftobedpe}'
        ' | cut -f 1-3'
        ' | bedtools slop -b 5000 -i stdin -g {input.fai}'
        ' ; '
        'bcftools view -f .,PASS {input.manta_vcf}'
        ' | {params.vcftobedpe}'
        ' | cut -f 4-6'
        ' | grep -v \'CHROM\''
        ' | bedtools slop -i stdin -g {input.fai} -b 5000'
        ' ; }}'
        ' | bedtools sort -i stdin'
        ' | bedtools merge -i stdin'
        ' > {output}'

# And one in BEDPE format
rule bedpe:
    input:
        manta_vcf = lambda wc: join(batch_by_name[wc.batch].tumor.dirpath, f'{wc.batch}-sv-prioritize-manta.vcf.gz')
    output:
        'umccrised/{batch}/structural/sv-prioritize-manta.bedpe'
    params:
        vcftobedpe = 'python2 ' + join(extras, 'svtools-master/vcfToBedpe')
    shell:
        'bcftools view -f .,PASS {input.manta_vcf}'
        ' | {params.vcftobedpe}'
        ' | cut -f 1-7'
        ' > {output}'


## IGV
# Create BAM and VCF files suitable for moving around easily. Right now this only uses the AZ300 gene list. It also needs to include Sean's cancer predisposition list and create proper Mini-BAMs and VCFs that include regions with +/- 1kb around all somatic SNVs, CNVs and SVs.
rule igv_bed:
    input:
        az300 = az300,
        vcf = join(run.date_dir, '{batch}-ensemble-annotated.vcf.gz'),
        manta = rules.ribbon.output[0]
    output:
        'umccrised/{batch}/igv/roi.bed'
    shell:
        '{{ '
        'gunzip -c {input.az300} | cut -f1-3'
        ' ; '
        'bcftools view -H {input.vcf} -Ov | awk -v OFS="\t" \'{{print $1, $2-100, $2+100}}\''
        ' ; '
        'cat {input.manta}'
        ' ; }} '
        ' | bedtools sort -i stdin'
        ' | bedtools merge -i stdin'
        ' > {output}'

rule igv_bam:
    input:
        bam = lambda wc: getattr(batch_by_name[wc.batch], wc.phenotype).bam,
        bed = rules.igv_bed.output[0]
    output:
        'umccrised/{batch}/igv/{phenotype}_mini.bam'
    threads: threads_max
    shell:
        'sambamba view -f bam -L {input.bed} {input.bam} -t {threads} -o {output}'
        ' && samtools index {output}'

## Additional information
# TODO: link it to MultiQC
rule log:
    input:
        join(run.date_dir, 'data_versions.csv'), join(run.date_dir, 'programs.txt'), run.config_dir
    output:
        'umccrised/log/data_versions.csv', 
        'umccrised/log/programs.txt', 
        'umccrised/log/config'
    params:
        log_dir = 'log'
    shell:
        'ln -s {input} {params.log_dir}'


rule sig_rmd:
    input:
        af_freqs = rules.af_freqs.output[0],
        af_freqs_az300 = rules.af_freqs_az300.output[0],
        vcf = rules.cgi.output[0]
    params:
        sig_rmd = get_sig_rmd_file(),
        tumor_name = lambda wc: batch_by_name[wc.batch].tumor.name
    output:
        'umccrised/{batch}/somatic/rstudio/sig.html'
    shell:
        'Rscript -e "rmarkdown::render(\'{params.sig_rmd}\', params=list('
        'af_freqs=\'{input.af_freqs}\', '
        'af_freqs_az300=\'{input.af_freqs_az300}\', '
        'vcf=\'{input.vcf}\', '
        'tumor_name=\'{params.tumor_name}\''
        '))"'
        ' && if [ -e x.txt ] ; then exit 1; fi'








